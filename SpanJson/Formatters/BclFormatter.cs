using System;
using System.Collections.Generic;
using SpanJson.Helpers;
using System.Buffers;

// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
namespace SpanJson.Formatters
{
    public sealed class SByteUtf16Formatter : IJsonFormatter<sbyte, char>
    {
        public static readonly SByteUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, sbyte value)
        {
            writer.WriteUtf16SByte(value);
        }

        public sbyte Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16SByte();
        }
    }
    public sealed class NullableSByteUtf16Formatter : IJsonFormatter<sbyte?, char>
    {
        public static readonly NullableSByteUtf16Formatter Default = new();
        private static readonly SByteUtf16Formatter ElementFormatter = SByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, sbyte? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public sbyte? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableSByteUtf16ArrayFormatter : IJsonFormatter<sbyte?[], char>
    {
        public static readonly NullableSByteUtf16ArrayFormatter Default = new();
        private static readonly NullableSByteUtf16Formatter ElementFormatter = NullableSByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, sbyte?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public sbyte?[] Deserialize(ref JsonReader<char> reader)
        {
            sbyte?[] temp = null;
            sbyte?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return [];
                }
                temp = ArrayPool<sbyte?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<sbyte?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableSByteUtf16ListFormatter : IJsonFormatter<List<sbyte?>, char>
    {
        public static readonly NullableSByteUtf16ListFormatter Default = new();
        private static readonly NullableSByteUtf16Formatter ElementFormatter = NullableSByteUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<sbyte?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
            writer.WriteUtf16EndArray();
        }

        public List<sbyte?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return [];
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<sbyte?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class SByteUtf16ArrayFormatter : IJsonFormatter<sbyte[], char>
    {
        public static readonly SByteUtf16ArrayFormatter Default = new();
        private static readonly SByteUtf16Formatter ElementFormatter = SByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, sbyte[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public sbyte[] Deserialize(ref JsonReader<char> reader)
        {
            sbyte[] temp = null;
            sbyte[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return [];
                }
                temp = ArrayPool<sbyte>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<sbyte>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class SByteUtf16ListFormatter : IJsonFormatter<List<sbyte>, char>
    {
        public static readonly SByteUtf16ListFormatter Default = new();
        private static readonly SByteUtf16Formatter ElementFormatter = SByteUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<sbyte> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<sbyte> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return [];
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<sbyte>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class SByteUtf8Formatter : IJsonFormatter<sbyte, byte>
    {
        public static readonly SByteUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, sbyte value)
        {
            writer.WriteUtf8SByte(value);
        }

        public sbyte Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8SByte();
        }
    }
    public sealed class NullableSByteUtf8Formatter : IJsonFormatter<sbyte?, byte>
    {
        public static readonly NullableSByteUtf8Formatter Default = new();
        private static readonly SByteUtf8Formatter ElementFormatter = SByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, sbyte? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public sbyte? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableSByteUtf8ArrayFormatter : IJsonFormatter<sbyte?[], byte>
    {
        public static readonly NullableSByteUtf8ArrayFormatter Default = new();
        private static readonly NullableSByteUtf8Formatter ElementFormatter = NullableSByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, sbyte?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public sbyte?[] Deserialize(ref JsonReader<byte> reader)
        {
            sbyte?[] temp = null;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return [];
                }
                temp = ArrayPool<sbyte?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    return [];
                }
                return FormatterUtils.CopyArray(temp, count);
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<sbyte?>.Shared.Return(temp);
                }
            }
        }
    }

    public sealed class NullableSByteUtf8ListFormatter : IJsonFormatter<List<sbyte?>, byte>
    {
        public static readonly NullableSByteUtf8ListFormatter Default = new();
        private static readonly NullableSByteUtf8Formatter ElementFormatter = NullableSByteUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<sbyte?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
            writer.WriteUtf8EndArray();
        }

        public List<sbyte?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<sbyte?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class SByteUtf8ArrayFormatter : IJsonFormatter<sbyte[], byte>
    {
        public static readonly SByteUtf8ArrayFormatter Default = new();
        private static readonly SByteUtf8Formatter ElementFormatter = SByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, sbyte[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public sbyte[] Deserialize(ref JsonReader<byte> reader)
        {
            sbyte[] temp = null;
            sbyte[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<sbyte>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<sbyte>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class SByteUtf8ListFormatter : IJsonFormatter<List<sbyte>, byte>
    {
        public static readonly SByteUtf8ListFormatter Default = new();
        private static readonly SByteUtf8Formatter ElementFormatter = SByteUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<sbyte> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
            writer.WriteUtf8EndArray();
        }

        public List<sbyte> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<sbyte>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int16Utf16Formatter : IJsonFormatter<short, char>
    {
        public static readonly Int16Utf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, short value)
        {
            writer.WriteUtf16Int16(value);
        }

        public short Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Int16();
        }
    }
    public sealed class NullableInt16Utf16Formatter : IJsonFormatter<short?, char>
    {
        public static readonly NullableInt16Utf16Formatter Default = new();
        private static readonly Int16Utf16Formatter ElementFormatter = Int16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, short? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public short? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt16Utf16ArrayFormatter : IJsonFormatter<short?[], char>
    {
        public static readonly NullableInt16Utf16ArrayFormatter Default = new();
        private static readonly NullableInt16Utf16Formatter ElementFormatter = NullableInt16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, short?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public short?[] Deserialize(ref JsonReader<char> reader)
        {
            short?[] temp = null;
            short?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<short?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<short?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt16Utf16ListFormatter : IJsonFormatter<List<short?>, char>
    {
        public static readonly NullableInt16Utf16ListFormatter Default = new();
        private static readonly NullableInt16Utf16Formatter ElementFormatter = NullableInt16Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<short?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<short?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<short?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int16Utf16ArrayFormatter : IJsonFormatter<short[], char>
    {
        public static readonly Int16Utf16ArrayFormatter Default = new();
        private static readonly Int16Utf16Formatter ElementFormatter = Int16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, short[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public short[] Deserialize(ref JsonReader<char> reader)
        {
            short[] temp = null;
            short[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<short>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<short>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int16Utf16ListFormatter : IJsonFormatter<List<short>, char>
    {
        public static readonly Int16Utf16ListFormatter Default = new();
        private static readonly Int16Utf16Formatter ElementFormatter = Int16Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<short> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<short> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<short>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int16Utf8Formatter : IJsonFormatter<short, byte>
    {
        public static readonly Int16Utf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, short value)
        {
            writer.WriteUtf8Int16(value);
        }

        public short Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Int16();
        }
    }
    public sealed class NullableInt16Utf8Formatter : IJsonFormatter<short?, byte>
    {
        public static readonly NullableInt16Utf8Formatter Default = new();
        private static readonly Int16Utf8Formatter ElementFormatter = Int16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, short? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public short? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt16Utf8ArrayFormatter : IJsonFormatter<short?[], byte>
    {
        public static readonly NullableInt16Utf8ArrayFormatter Default = new();
        private static readonly NullableInt16Utf8Formatter ElementFormatter = NullableInt16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, short?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public short?[] Deserialize(ref JsonReader<byte> reader)
        {
            short?[] temp = null;
            short?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<short?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<short?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt16Utf8ListFormatter : IJsonFormatter<List<short?>, byte>
    {
        public static readonly NullableInt16Utf8ListFormatter Default = new();
        private static readonly NullableInt16Utf8Formatter ElementFormatter = NullableInt16Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<short?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<short?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return [];
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<short?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int16Utf8ArrayFormatter : IJsonFormatter<short[], byte>
    {
        public static readonly Int16Utf8ArrayFormatter Default = new();
        private static readonly Int16Utf8Formatter ElementFormatter = Int16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, short[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public short[] Deserialize(ref JsonReader<byte> reader)
        {
            short[] temp = null;
            short[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<short>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<short>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int16Utf8ListFormatter : IJsonFormatter<List<short>, byte>
    {
        public static readonly Int16Utf8ListFormatter Default = new();
        private static readonly Int16Utf8Formatter ElementFormatter = Int16Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<short> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
            writer.WriteUtf8EndArray();
        }

        public List<short> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<short>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int32Utf16Formatter : IJsonFormatter<int, char>
    {
        public static readonly Int32Utf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, int value)
        {
            writer.WriteUtf16Int32(value);
        }

        public int Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Int32();
        }
    }
    public sealed class NullableInt32Utf16Formatter : IJsonFormatter<int?, char>
    {
        public static readonly NullableInt32Utf16Formatter Default = new();
        private static readonly Int32Utf16Formatter ElementFormatter = Int32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, int? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public int? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt32Utf16ArrayFormatter : IJsonFormatter<int?[], char>
    {
        public static readonly NullableInt32Utf16ArrayFormatter Default = new();
        private static readonly NullableInt32Utf16Formatter ElementFormatter = NullableInt32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, int?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public int?[] Deserialize(ref JsonReader<char> reader)
        {
            int?[] temp = null;
            int?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<int?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<int?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt32Utf16ListFormatter : IJsonFormatter<List<int?>, char>
    {
        public static readonly NullableInt32Utf16ListFormatter Default = new();
        private static readonly NullableInt32Utf16Formatter ElementFormatter = NullableInt32Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<int?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<int?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<int?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int32Utf16ArrayFormatter : IJsonFormatter<int[], char>
    {
        public static readonly Int32Utf16ArrayFormatter Default = new();
        private static readonly Int32Utf16Formatter ElementFormatter = Int32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, int[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public int[] Deserialize(ref JsonReader<char> reader)
        {
            int[] temp = null;
            int[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<int>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<int>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int32Utf16ListFormatter : IJsonFormatter<List<int>, char>
    {
        public static readonly Int32Utf16ListFormatter Default = new();
        private static readonly Int32Utf16Formatter ElementFormatter = Int32Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<int> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<int> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<int>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int32Utf8Formatter : IJsonFormatter<int, byte>
    {
        public static readonly Int32Utf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, int value)
        {
            writer.WriteUtf8Int32(value);
        }

        public int Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Int32();
        }
    }
    public sealed class NullableInt32Utf8Formatter : IJsonFormatter<int?, byte>
    {
        public static readonly NullableInt32Utf8Formatter Default = new();
        private static readonly Int32Utf8Formatter ElementFormatter = Int32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, int? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public int? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt32Utf8ArrayFormatter : IJsonFormatter<int?[], byte>
    {
        public static readonly NullableInt32Utf8ArrayFormatter Default = new();
        private static readonly NullableInt32Utf8Formatter ElementFormatter = NullableInt32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, int?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public int?[] Deserialize(ref JsonReader<byte> reader)
        {
            int?[] temp = null;
            int?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return [];
                }
                temp = ArrayPool<int?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<int?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt32Utf8ListFormatter : IJsonFormatter<List<int?>, byte>
    {
        public static readonly NullableInt32Utf8ListFormatter Default = new();
        private static readonly NullableInt32Utf8Formatter ElementFormatter = NullableInt32Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<int?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<int?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<int?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int32Utf8ArrayFormatter : IJsonFormatter<int[], byte>
    {
        public static readonly Int32Utf8ArrayFormatter Default = new();
        private static readonly Int32Utf8Formatter ElementFormatter = Int32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, int[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public int[] Deserialize(ref JsonReader<byte> reader)
        {
            int[] temp = null;
            int[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<int>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<int>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int32Utf8ListFormatter : IJsonFormatter<List<int>, byte>
    {
        public static readonly Int32Utf8ListFormatter Default = new();
        private static readonly Int32Utf8Formatter ElementFormatter = Int32Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<int> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<int> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<int>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int64Utf16Formatter : IJsonFormatter<long, char>
    {
        public static readonly Int64Utf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, long value)
        {
            writer.WriteUtf16Int64(value);
        }

        public long Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Int64();
        }
    }
    public sealed class NullableInt64Utf16Formatter : IJsonFormatter<long?, char>
    {
        public static readonly NullableInt64Utf16Formatter Default = new();
        private static readonly Int64Utf16Formatter ElementFormatter = Int64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, long? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public long? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt64Utf16ArrayFormatter : IJsonFormatter<long?[], char>
    {
        public static readonly NullableInt64Utf16ArrayFormatter Default = new();
        private static readonly NullableInt64Utf16Formatter ElementFormatter = NullableInt64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, long?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public long?[] Deserialize(ref JsonReader<char> reader)
        {
            long?[] temp = null;
            long?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<long?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<long?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt64Utf16ListFormatter : IJsonFormatter<List<long?>, char>
    {
        public static readonly NullableInt64Utf16ListFormatter Default = new();
        private static readonly NullableInt64Utf16Formatter ElementFormatter = NullableInt64Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<long?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<long?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<long?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int64Utf16ArrayFormatter : IJsonFormatter<long[], char>
    {
        public static readonly Int64Utf16ArrayFormatter Default = new();
        private static readonly Int64Utf16Formatter ElementFormatter = Int64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, long[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public long[] Deserialize(ref JsonReader<char> reader)
        {
            long[] temp = null;
            long[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<long>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<long>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int64Utf16ListFormatter : IJsonFormatter<List<long>, char>
    {
        public static readonly Int64Utf16ListFormatter Default = new();
        private static readonly Int64Utf16Formatter ElementFormatter = Int64Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<long> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<long> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<long>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int64Utf8Formatter : IJsonFormatter<long, byte>
    {
        public static readonly Int64Utf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, long value)
        {
            writer.WriteUtf8Int64(value);
        }

        public long Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Int64();
        }
    }
    public sealed class NullableInt64Utf8Formatter : IJsonFormatter<long?, byte>
    {
        public static readonly NullableInt64Utf8Formatter Default = new();
        private static readonly Int64Utf8Formatter ElementFormatter = Int64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, long? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public long? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt64Utf8ArrayFormatter : IJsonFormatter<long?[], byte>
    {
        public static readonly NullableInt64Utf8ArrayFormatter Default = new();
        private static readonly NullableInt64Utf8Formatter ElementFormatter = NullableInt64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, long?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public long?[] Deserialize(ref JsonReader<byte> reader)
        {
            long?[] temp = null;
            long?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<long?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<long?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt64Utf8ListFormatter : IJsonFormatter<List<long?>, byte>
    {
        public static readonly NullableInt64Utf8ListFormatter Default = new();
        private static readonly NullableInt64Utf8Formatter ElementFormatter = NullableInt64Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<long?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<long?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<long?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int64Utf8ArrayFormatter : IJsonFormatter<long[], byte>
    {
        public static readonly Int64Utf8ArrayFormatter Default = new();
        private static readonly Int64Utf8Formatter ElementFormatter = Int64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, long[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public long[] Deserialize(ref JsonReader<byte> reader)
        {
            long[] temp = null;
            long[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<long>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<long>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int64Utf8ListFormatter : IJsonFormatter<List<long>, byte>
    {
        public static readonly Int64Utf8ListFormatter Default = new();
        private static readonly Int64Utf8Formatter ElementFormatter = Int64Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<long> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<long> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<long>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class ByteUtf16Formatter : IJsonFormatter<byte, char>
    {
        public static readonly ByteUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, byte value)
        {
            writer.WriteUtf16Byte(value);
        }

        public byte Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Byte();
        }
    }
    public sealed class NullableByteUtf16Formatter : IJsonFormatter<byte?, char>
    {
        public static readonly NullableByteUtf16Formatter Default = new();
        private static readonly ByteUtf16Formatter ElementFormatter = ByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, byte? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public byte? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableByteUtf16ArrayFormatter : IJsonFormatter<byte?[], char>
    {
        public static readonly NullableByteUtf16ArrayFormatter Default = new();
        private static readonly NullableByteUtf16Formatter ElementFormatter = NullableByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, byte?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public byte?[] Deserialize(ref JsonReader<char> reader)
        {
            byte?[] temp = null;
            byte?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<byte?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<byte?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableByteUtf16ListFormatter : IJsonFormatter<List<byte?>, char>
    {
        public static readonly NullableByteUtf16ListFormatter Default = new();
        private static readonly NullableByteUtf16Formatter ElementFormatter = NullableByteUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<byte?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<byte?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<byte?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class ByteUtf16ArrayFormatter : IJsonFormatter<byte[], char>
    {
        public static readonly ByteUtf16ArrayFormatter Default = new();
        private static readonly ByteUtf16Formatter ElementFormatter = ByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, byte[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public byte[] Deserialize(ref JsonReader<char> reader)
        {
            byte[] temp = null;
            byte[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<byte>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<byte>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class ByteUtf16ListFormatter : IJsonFormatter<List<byte>, char>
    {
        public static readonly ByteUtf16ListFormatter Default = new();
        private static readonly ByteUtf16Formatter ElementFormatter = ByteUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<byte> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<byte> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<byte>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class ByteUtf8Formatter : IJsonFormatter<byte, byte>
    {
        public static readonly ByteUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, byte value)
        {
            writer.WriteUtf8Byte(value);
        }

        public byte Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Byte();
        }
    }
    public sealed class NullableByteUtf8Formatter : IJsonFormatter<byte?, byte>
    {
        public static readonly NullableByteUtf8Formatter Default = new();
        private static readonly ByteUtf8Formatter ElementFormatter = ByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, byte? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public byte? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableByteUtf8ArrayFormatter : IJsonFormatter<byte?[], byte>
    {
        public static readonly NullableByteUtf8ArrayFormatter Default = new();
        private static readonly NullableByteUtf8Formatter ElementFormatter = NullableByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, byte?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public byte?[] Deserialize(ref JsonReader<byte> reader)
        {
            byte?[] temp = null;
            byte?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<byte?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<byte?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableByteUtf8ListFormatter : IJsonFormatter<List<byte?>, byte>
    {
        public static readonly NullableByteUtf8ListFormatter Default = new();
        private static readonly NullableByteUtf8Formatter ElementFormatter = NullableByteUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<byte?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<byte?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<byte?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class ByteUtf8ArrayFormatter : IJsonFormatter<byte[], byte>
    {
        public static readonly ByteUtf8ArrayFormatter Default = new();
        private static readonly ByteUtf8Formatter ElementFormatter = ByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, byte[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public byte[] Deserialize(ref JsonReader<byte> reader)
        {
            byte[] temp = null;
            byte[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<byte>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<byte>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class ByteUtf8ListFormatter : IJsonFormatter<List<byte>, byte>
    {
        public static readonly ByteUtf8ListFormatter Default = new();
        private static readonly ByteUtf8Formatter ElementFormatter = ByteUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<byte> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<byte> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<byte>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt16Utf16Formatter : IJsonFormatter<ushort, char>
    {
        public static readonly UInt16Utf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, ushort value)
        {
            writer.WriteUtf16UInt16(value);
        }

        public ushort Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16UInt16();
        }
    }
    public sealed class NullableUInt16Utf16Formatter : IJsonFormatter<ushort?, char>
    {
        public static readonly NullableUInt16Utf16Formatter Default = new();
        private static readonly UInt16Utf16Formatter ElementFormatter = UInt16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, ushort? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public ushort? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt16Utf16ArrayFormatter : IJsonFormatter<ushort?[], char>
    {
        public static readonly NullableUInt16Utf16ArrayFormatter Default = new();
        private static readonly NullableUInt16Utf16Formatter ElementFormatter = NullableUInt16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, ushort?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public ushort?[] Deserialize(ref JsonReader<char> reader)
        {
            ushort?[] temp = null;
            ushort?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<ushort?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<ushort?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt16Utf16ListFormatter : IJsonFormatter<List<ushort?>, char>
    {
        public static readonly NullableUInt16Utf16ListFormatter Default = new();
        private static readonly NullableUInt16Utf16Formatter ElementFormatter = NullableUInt16Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<ushort?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<ushort?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<ushort?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt16Utf16ArrayFormatter : IJsonFormatter<ushort[], char>
    {
        public static readonly UInt16Utf16ArrayFormatter Default = new();
        private static readonly UInt16Utf16Formatter ElementFormatter = UInt16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, ushort[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public ushort[] Deserialize(ref JsonReader<char> reader)
        {
            ushort[] temp = null;
            ushort[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<ushort>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<ushort>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt16Utf16ListFormatter : IJsonFormatter<List<ushort>, char>
    {
        public static readonly UInt16Utf16ListFormatter Default = new();
        private static readonly UInt16Utf16Formatter ElementFormatter = UInt16Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<ushort> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<ushort> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<ushort>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt16Utf8Formatter : IJsonFormatter<ushort, byte>
    {
        public static readonly UInt16Utf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, ushort value)
        {
            writer.WriteUtf8UInt16(value);
        }

        public ushort Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8UInt16();
        }
    }
    public sealed class NullableUInt16Utf8Formatter : IJsonFormatter<ushort?, byte>
    {
        public static readonly NullableUInt16Utf8Formatter Default = new();
        private static readonly UInt16Utf8Formatter ElementFormatter = UInt16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, ushort? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public ushort? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt16Utf8ArrayFormatter : IJsonFormatter<ushort?[], byte>
    {
        public static readonly NullableUInt16Utf8ArrayFormatter Default = new();
        private static readonly NullableUInt16Utf8Formatter ElementFormatter = NullableUInt16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, ushort?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public ushort?[] Deserialize(ref JsonReader<byte> reader)
        {
            ushort?[] temp = null;
            ushort?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<ushort?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<ushort?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt16Utf8ListFormatter : IJsonFormatter<List<ushort?>, byte>
    {
        public static readonly NullableUInt16Utf8ListFormatter Default = new();
        private static readonly NullableUInt16Utf8Formatter ElementFormatter = NullableUInt16Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<ushort?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<ushort?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<ushort?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt16Utf8ArrayFormatter : IJsonFormatter<ushort[], byte>
    {
        public static readonly UInt16Utf8ArrayFormatter Default = new();
        private static readonly UInt16Utf8Formatter ElementFormatter = UInt16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, ushort[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public ushort[] Deserialize(ref JsonReader<byte> reader)
        {
            ushort[] temp = null;
            ushort[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<ushort>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<ushort>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt16Utf8ListFormatter : IJsonFormatter<List<ushort>, byte>
    {
        public static readonly UInt16Utf8ListFormatter Default = new();
        private static readonly UInt16Utf8Formatter ElementFormatter = UInt16Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<ushort> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<ushort> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<ushort>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt32Utf16Formatter : IJsonFormatter<uint, char>
    {
        public static readonly UInt32Utf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, uint value)
        {
            writer.WriteUtf16UInt32(value);
        }

        public uint Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16UInt32();
        }
    }
    public sealed class NullableUInt32Utf16Formatter : IJsonFormatter<uint?, char>
    {
        public static readonly NullableUInt32Utf16Formatter Default = new();
        private static readonly UInt32Utf16Formatter ElementFormatter = UInt32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, uint? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public uint? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt32Utf16ArrayFormatter : IJsonFormatter<uint?[], char>
    {
        public static readonly NullableUInt32Utf16ArrayFormatter Default = new();
        private static readonly NullableUInt32Utf16Formatter ElementFormatter = NullableUInt32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, uint?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public uint?[] Deserialize(ref JsonReader<char> reader)
        {
            uint?[] temp = null;
            uint?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<uint?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<uint?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt32Utf16ListFormatter : IJsonFormatter<List<uint?>, char>
    {
        public static readonly NullableUInt32Utf16ListFormatter Default = new();
        private static readonly NullableUInt32Utf16Formatter ElementFormatter = NullableUInt32Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<uint?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<uint?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<uint?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt32Utf16ArrayFormatter : IJsonFormatter<uint[], char>
    {
        public static readonly UInt32Utf16ArrayFormatter Default = new();
        private static readonly UInt32Utf16Formatter ElementFormatter = UInt32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, uint[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public uint[] Deserialize(ref JsonReader<char> reader)
        {
            uint[] temp = null;
            uint[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<uint>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<uint>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt32Utf16ListFormatter : IJsonFormatter<List<uint>, char>
    {
        public static readonly UInt32Utf16ListFormatter Default = new();
        private static readonly UInt32Utf16Formatter ElementFormatter = UInt32Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<uint> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<uint> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<uint>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt32Utf8Formatter : IJsonFormatter<uint, byte>
    {
        public static readonly UInt32Utf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, uint value)
        {
            writer.WriteUtf8UInt32(value);
        }

        public uint Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8UInt32();
        }
    }
    public sealed class NullableUInt32Utf8Formatter : IJsonFormatter<uint?, byte>
    {
        public static readonly NullableUInt32Utf8Formatter Default = new();
        private static readonly UInt32Utf8Formatter ElementFormatter = UInt32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, uint? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public uint? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt32Utf8ArrayFormatter : IJsonFormatter<uint?[], byte>
    {
        public static readonly NullableUInt32Utf8ArrayFormatter Default = new();
        private static readonly NullableUInt32Utf8Formatter ElementFormatter = NullableUInt32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, uint?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public uint?[] Deserialize(ref JsonReader<byte> reader)
        {
            uint?[] temp = null;
            uint?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<uint?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<uint?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt32Utf8ListFormatter : IJsonFormatter<List<uint?>, byte>
    {
        public static readonly NullableUInt32Utf8ListFormatter Default = new();
        private static readonly NullableUInt32Utf8Formatter ElementFormatter = NullableUInt32Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<uint?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<uint?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<uint?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt32Utf8ArrayFormatter : IJsonFormatter<uint[], byte>
    {
        public static readonly UInt32Utf8ArrayFormatter Default = new();
        private static readonly UInt32Utf8Formatter ElementFormatter = UInt32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, uint[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public uint[] Deserialize(ref JsonReader<byte> reader)
        {
            uint[] temp = null;
            uint[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<uint>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<uint>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt32Utf8ListFormatter : IJsonFormatter<List<uint>, byte>
    {
        public static readonly UInt32Utf8ListFormatter Default = new();
        private static readonly UInt32Utf8Formatter ElementFormatter = UInt32Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<uint> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<uint> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<uint>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt64Utf16Formatter : IJsonFormatter<ulong, char>
    {
        public static readonly UInt64Utf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, ulong value)
        {
            writer.WriteUtf16UInt64(value);
        }

        public ulong Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16UInt64();
        }
    }
    public sealed class NullableUInt64Utf16Formatter : IJsonFormatter<ulong?, char>
    {
        public static readonly NullableUInt64Utf16Formatter Default = new();
        private static readonly UInt64Utf16Formatter ElementFormatter = UInt64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, ulong? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public ulong? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt64Utf16ArrayFormatter : IJsonFormatter<ulong?[], char>
    {
        public static readonly NullableUInt64Utf16ArrayFormatter Default = new();
        private static readonly NullableUInt64Utf16Formatter ElementFormatter = NullableUInt64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, ulong?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public ulong?[] Deserialize(ref JsonReader<char> reader)
        {
            ulong?[] temp = null;
            ulong?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<ulong?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<ulong?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt64Utf16ListFormatter : IJsonFormatter<List<ulong?>, char>
    {
        public static readonly NullableUInt64Utf16ListFormatter Default = new();
        private static readonly NullableUInt64Utf16Formatter ElementFormatter = NullableUInt64Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<ulong?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<ulong?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<ulong?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt64Utf16ArrayFormatter : IJsonFormatter<ulong[], char>
    {
        public static readonly UInt64Utf16ArrayFormatter Default = new();
        private static readonly UInt64Utf16Formatter ElementFormatter = UInt64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, ulong[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public ulong[] Deserialize(ref JsonReader<char> reader)
        {
            ulong[] temp = null;
            ulong[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<ulong>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<ulong>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt64Utf16ListFormatter : IJsonFormatter<List<ulong>, char>
    {
        public static readonly UInt64Utf16ListFormatter Default = new();
        private static readonly UInt64Utf16Formatter ElementFormatter = UInt64Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<ulong> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<ulong> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<ulong>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt64Utf8Formatter : IJsonFormatter<ulong, byte>
    {
        public static readonly UInt64Utf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, ulong value)
        {
            writer.WriteUtf8UInt64(value);
        }

        public ulong Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8UInt64();
        }
    }
    public sealed class NullableUInt64Utf8Formatter : IJsonFormatter<ulong?, byte>
    {
        public static readonly NullableUInt64Utf8Formatter Default = new();
        private static readonly UInt64Utf8Formatter ElementFormatter = UInt64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, ulong? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public ulong? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt64Utf8ArrayFormatter : IJsonFormatter<ulong?[], byte>
    {
        public static readonly NullableUInt64Utf8ArrayFormatter Default = new();
        private static readonly NullableUInt64Utf8Formatter ElementFormatter = NullableUInt64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, ulong?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public ulong?[] Deserialize(ref JsonReader<byte> reader)
        {
            ulong?[] temp = null;
            ulong?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<ulong?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<ulong?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt64Utf8ListFormatter : IJsonFormatter<List<ulong?>, byte>
    {
        public static readonly NullableUInt64Utf8ListFormatter Default = new();
        private static readonly NullableUInt64Utf8Formatter ElementFormatter = NullableUInt64Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<ulong?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<ulong?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<ulong?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt64Utf8ArrayFormatter : IJsonFormatter<ulong[], byte>
    {
        public static readonly UInt64Utf8ArrayFormatter Default = new();
        private static readonly UInt64Utf8Formatter ElementFormatter = UInt64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, ulong[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public ulong[] Deserialize(ref JsonReader<byte> reader)
        {
            ulong[] temp = null;
            ulong[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<ulong>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<ulong>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt64Utf8ListFormatter : IJsonFormatter<List<ulong>, byte>
    {
        public static readonly UInt64Utf8ListFormatter Default = new();
        private static readonly UInt64Utf8Formatter ElementFormatter = UInt64Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<ulong> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<ulong> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<ulong>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class SingleUtf16Formatter : IJsonFormatter<float, char>
    {
        public static readonly SingleUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, float value)
        {
            writer.WriteUtf16Single(value);
        }

        public float Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Single();
        }
    }
    public sealed class NullableSingleUtf16Formatter : IJsonFormatter<float?, char>
    {
        public static readonly NullableSingleUtf16Formatter Default = new();
        private static readonly SingleUtf16Formatter ElementFormatter = SingleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, float? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public float? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableSingleUtf16ArrayFormatter : IJsonFormatter<float?[], char>
    {
        public static readonly NullableSingleUtf16ArrayFormatter Default = new();
        private static readonly NullableSingleUtf16Formatter ElementFormatter = NullableSingleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, float?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public float?[] Deserialize(ref JsonReader<char> reader)
        {
            float?[] temp = null;
            float?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<float?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<float?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableSingleUtf16ListFormatter : IJsonFormatter<List<float?>, char>
    {
        public static readonly NullableSingleUtf16ListFormatter Default = new();
        private static readonly NullableSingleUtf16Formatter ElementFormatter = NullableSingleUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<float?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<float?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<float?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class SingleUtf16ArrayFormatter : IJsonFormatter<float[], char>
    {
        public static readonly SingleUtf16ArrayFormatter Default = new();
        private static readonly SingleUtf16Formatter ElementFormatter = SingleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, float[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public float[] Deserialize(ref JsonReader<char> reader)
        {
            float[] temp = null;
            float[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<float>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<float>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class SingleUtf16ListFormatter : IJsonFormatter<List<float>, char>
    {
        public static readonly SingleUtf16ListFormatter Default = new();
        private static readonly SingleUtf16Formatter ElementFormatter = SingleUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<float> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<float> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<float>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class SingleUtf8Formatter : IJsonFormatter<float, byte>
    {
        public static readonly SingleUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, float value)
        {
            writer.WriteUtf8Single(value);
        }

        public float Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Single();
        }
    }
    public sealed class NullableSingleUtf8Formatter : IJsonFormatter<float?, byte>
    {
        public static readonly NullableSingleUtf8Formatter Default = new();
        private static readonly SingleUtf8Formatter ElementFormatter = SingleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, float? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public float? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableSingleUtf8ArrayFormatter : IJsonFormatter<float?[], byte>
    {
        public static readonly NullableSingleUtf8ArrayFormatter Default = new();
        private static readonly NullableSingleUtf8Formatter ElementFormatter = NullableSingleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, float?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public float?[] Deserialize(ref JsonReader<byte> reader)
        {
            float?[] temp = null;
            float?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<float?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<float?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableSingleUtf8ListFormatter : IJsonFormatter<List<float?>, byte>
    {
        public static readonly NullableSingleUtf8ListFormatter Default = new();
        private static readonly NullableSingleUtf8Formatter ElementFormatter = NullableSingleUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<float?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<float?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<float?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class SingleUtf8ArrayFormatter : IJsonFormatter<float[], byte>
    {
        public static readonly SingleUtf8ArrayFormatter Default = new();
        private static readonly SingleUtf8Formatter ElementFormatter = SingleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, float[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public float[] Deserialize(ref JsonReader<byte> reader)
        {
            float[] temp = null;
            float[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<float>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<float>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class SingleUtf8ListFormatter : IJsonFormatter<List<float>, byte>
    {
        public static readonly SingleUtf8ListFormatter Default = new();
        private static readonly SingleUtf8Formatter ElementFormatter = SingleUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<float> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<float> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<float>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DoubleUtf16Formatter : IJsonFormatter<double, char>
    {
        public static readonly DoubleUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, double value)
        {
            writer.WriteUtf16Double(value);
        }

        public double Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Double();
        }
    }
    public sealed class NullableDoubleUtf16Formatter : IJsonFormatter<double?, char>
    {
        public static readonly NullableDoubleUtf16Formatter Default = new();
        private static readonly DoubleUtf16Formatter ElementFormatter = DoubleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, double? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public double? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDoubleUtf16ArrayFormatter : IJsonFormatter<double?[], char>
    {
        public static readonly NullableDoubleUtf16ArrayFormatter Default = new();
        private static readonly NullableDoubleUtf16Formatter ElementFormatter = NullableDoubleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, double?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public double?[] Deserialize(ref JsonReader<char> reader)
        {
            double?[] temp = null;
            double?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<double?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<double?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDoubleUtf16ListFormatter : IJsonFormatter<List<double?>, char>
    {
        public static readonly NullableDoubleUtf16ListFormatter Default = new();
        private static readonly NullableDoubleUtf16Formatter ElementFormatter = NullableDoubleUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<double?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<double?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<double?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DoubleUtf16ArrayFormatter : IJsonFormatter<double[], char>
    {
        public static readonly DoubleUtf16ArrayFormatter Default = new();
        private static readonly DoubleUtf16Formatter ElementFormatter = DoubleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, double[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public double[] Deserialize(ref JsonReader<char> reader)
        {
            double[] temp = null;
            double[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<double>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<double>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DoubleUtf16ListFormatter : IJsonFormatter<List<double>, char>
    {
        public static readonly DoubleUtf16ListFormatter Default = new();
        private static readonly DoubleUtf16Formatter ElementFormatter = DoubleUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<double> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<double> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<double>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DoubleUtf8Formatter : IJsonFormatter<double, byte>
    {
        public static readonly DoubleUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, double value)
        {
            writer.WriteUtf8Double(value);
        }

        public double Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Double();
        }
    }
    public sealed class NullableDoubleUtf8Formatter : IJsonFormatter<double?, byte>
    {
        public static readonly NullableDoubleUtf8Formatter Default = new();
        private static readonly DoubleUtf8Formatter ElementFormatter = DoubleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, double? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public double? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDoubleUtf8ArrayFormatter : IJsonFormatter<double?[], byte>
    {
        public static readonly NullableDoubleUtf8ArrayFormatter Default = new();
        private static readonly NullableDoubleUtf8Formatter ElementFormatter = NullableDoubleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, double?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public double?[] Deserialize(ref JsonReader<byte> reader)
        {
            double?[] temp = null;
            double?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<double?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<double?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDoubleUtf8ListFormatter : IJsonFormatter<List<double?>, byte>
    {
        public static readonly NullableDoubleUtf8ListFormatter Default = new();
        private static readonly NullableDoubleUtf8Formatter ElementFormatter = NullableDoubleUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<double?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<double?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<double?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DoubleUtf8ArrayFormatter : IJsonFormatter<double[], byte>
    {
        public static readonly DoubleUtf8ArrayFormatter Default = new();
        private static readonly DoubleUtf8Formatter ElementFormatter = DoubleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, double[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public double[] Deserialize(ref JsonReader<byte> reader)
        {
            double[] temp = null;
            double[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<double>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<double>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DoubleUtf8ListFormatter : IJsonFormatter<List<double>, byte>
    {
        public static readonly DoubleUtf8ListFormatter Default = new();
        private static readonly DoubleUtf8Formatter ElementFormatter = DoubleUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<double> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<double> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<double>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DecimalUtf16Formatter : IJsonFormatter<decimal, char>
    {
        public static readonly DecimalUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, decimal value)
        {
            writer.WriteUtf16Decimal(value);
        }

        public decimal Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Decimal();
        }
    }
    public sealed class NullableDecimalUtf16Formatter : IJsonFormatter<decimal?, char>
    {
        public static readonly NullableDecimalUtf16Formatter Default = new();
        private static readonly DecimalUtf16Formatter ElementFormatter = DecimalUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, decimal? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public decimal? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDecimalUtf16ArrayFormatter : IJsonFormatter<decimal?[], char>
    {
        public static readonly NullableDecimalUtf16ArrayFormatter Default = new();
        private static readonly NullableDecimalUtf16Formatter ElementFormatter = NullableDecimalUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, decimal?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public decimal?[] Deserialize(ref JsonReader<char> reader)
        {
            decimal?[] temp = null;
            decimal?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<decimal?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<decimal?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDecimalUtf16ListFormatter : IJsonFormatter<List<decimal?>, char>
    {
        public static readonly NullableDecimalUtf16ListFormatter Default = new();
        private static readonly NullableDecimalUtf16Formatter ElementFormatter = NullableDecimalUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<decimal?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<decimal?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<decimal?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DecimalUtf16ArrayFormatter : IJsonFormatter<decimal[], char>
    {
        public static readonly DecimalUtf16ArrayFormatter Default = new();
        private static readonly DecimalUtf16Formatter ElementFormatter = DecimalUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, decimal[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public decimal[] Deserialize(ref JsonReader<char> reader)
        {
            decimal[] temp = null;
            decimal[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<decimal>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<decimal>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DecimalUtf16ListFormatter : IJsonFormatter<List<decimal>, char>
    {
        public static readonly DecimalUtf16ListFormatter Default = new();
        private static readonly DecimalUtf16Formatter ElementFormatter = DecimalUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<decimal> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<decimal> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<decimal>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DecimalUtf8Formatter : IJsonFormatter<decimal, byte>
    {
        public static readonly DecimalUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, decimal value)
        {
            writer.WriteUtf8Decimal(value);
        }

        public decimal Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Decimal();
        }
    }
    public sealed class NullableDecimalUtf8Formatter : IJsonFormatter<decimal?, byte>
    {
        public static readonly NullableDecimalUtf8Formatter Default = new();
        private static readonly DecimalUtf8Formatter ElementFormatter = DecimalUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, decimal? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public decimal? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDecimalUtf8ArrayFormatter : IJsonFormatter<decimal?[], byte>
    {
        public static readonly NullableDecimalUtf8ArrayFormatter Default = new();
        private static readonly NullableDecimalUtf8Formatter ElementFormatter = NullableDecimalUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, decimal?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public decimal?[] Deserialize(ref JsonReader<byte> reader)
        {
            decimal?[] temp = null;
            decimal?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<decimal?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<decimal?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDecimalUtf8ListFormatter : IJsonFormatter<List<decimal?>, byte>
    {
        public static readonly NullableDecimalUtf8ListFormatter Default = new();
        private static readonly NullableDecimalUtf8Formatter ElementFormatter = NullableDecimalUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<decimal?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<decimal?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<decimal?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DecimalUtf8ArrayFormatter : IJsonFormatter<decimal[], byte>
    {
        public static readonly DecimalUtf8ArrayFormatter Default = new();
        private static readonly DecimalUtf8Formatter ElementFormatter = DecimalUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, decimal[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public decimal[] Deserialize(ref JsonReader<byte> reader)
        {
            decimal[] temp = null;
            decimal[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<decimal>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<decimal>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DecimalUtf8ListFormatter : IJsonFormatter<List<decimal>, byte>
    {
        public static readonly DecimalUtf8ListFormatter Default = new();
        private static readonly DecimalUtf8Formatter ElementFormatter = DecimalUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<decimal> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<decimal> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<decimal>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class BooleanUtf16Formatter : IJsonFormatter<bool, char>
    {
        public static readonly BooleanUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, bool value)
        {
            writer.WriteUtf16Boolean(value);
        }

        public bool Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Boolean();
        }
    }
    public sealed class NullableBooleanUtf16Formatter : IJsonFormatter<bool?, char>
    {
        public static readonly NullableBooleanUtf16Formatter Default = new();
        private static readonly BooleanUtf16Formatter ElementFormatter = BooleanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, bool? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public bool? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableBooleanUtf16ArrayFormatter : IJsonFormatter<bool?[], char>
    {
        public static readonly NullableBooleanUtf16ArrayFormatter Default = new();
        private static readonly NullableBooleanUtf16Formatter ElementFormatter = NullableBooleanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, bool?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public bool?[] Deserialize(ref JsonReader<char> reader)
        {
            bool?[] temp = null;
            bool?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<bool?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<bool?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableBooleanUtf16ListFormatter : IJsonFormatter<List<bool?>, char>
    {
        public static readonly NullableBooleanUtf16ListFormatter Default = new();
        private static readonly NullableBooleanUtf16Formatter ElementFormatter = NullableBooleanUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<bool?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<bool?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<bool?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class BooleanUtf16ArrayFormatter : IJsonFormatter<bool[], char>
    {
        public static readonly BooleanUtf16ArrayFormatter Default = new();
        private static readonly BooleanUtf16Formatter ElementFormatter = BooleanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, bool[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public bool[] Deserialize(ref JsonReader<char> reader)
        {
            bool[] temp = null;
            bool[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<bool>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<bool>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class BooleanUtf16ListFormatter : IJsonFormatter<List<bool>, char>
    {
        public static readonly BooleanUtf16ListFormatter Default = new();
        private static readonly BooleanUtf16Formatter ElementFormatter = BooleanUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<bool> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<bool> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<bool>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class BooleanUtf8Formatter : IJsonFormatter<bool, byte>
    {
        public static readonly BooleanUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, bool value)
        {
            writer.WriteUtf8Boolean(value);
        }

        public bool Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Boolean();
        }
    }
    public sealed class NullableBooleanUtf8Formatter : IJsonFormatter<bool?, byte>
    {
        public static readonly NullableBooleanUtf8Formatter Default = new();
        private static readonly BooleanUtf8Formatter ElementFormatter = BooleanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, bool? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public bool? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableBooleanUtf8ArrayFormatter : IJsonFormatter<bool?[], byte>
    {
        public static readonly NullableBooleanUtf8ArrayFormatter Default = new();
        private static readonly NullableBooleanUtf8Formatter ElementFormatter = NullableBooleanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, bool?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public bool?[] Deserialize(ref JsonReader<byte> reader)
        {
            bool?[] temp = null;
            bool?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<bool?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<bool?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableBooleanUtf8ListFormatter : IJsonFormatter<List<bool?>, byte>
    {
        public static readonly NullableBooleanUtf8ListFormatter Default = new();
        private static readonly NullableBooleanUtf8Formatter ElementFormatter = NullableBooleanUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<bool?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<bool?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<bool?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class BooleanUtf8ArrayFormatter : IJsonFormatter<bool[], byte>
    {
        public static readonly BooleanUtf8ArrayFormatter Default = new();
        private static readonly BooleanUtf8Formatter ElementFormatter = BooleanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, bool[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public bool[] Deserialize(ref JsonReader<byte> reader)
        {
            bool[] temp = null;
            bool[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<bool>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<bool>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class BooleanUtf8ListFormatter : IJsonFormatter<List<bool>, byte>
    {
        public static readonly BooleanUtf8ListFormatter Default = new();
        private static readonly BooleanUtf8Formatter ElementFormatter = BooleanUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<bool> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<bool> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<bool>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class CharUtf16Formatter : IJsonFormatter<char, char>
    {
        public static readonly CharUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, char value)
        {
            writer.WriteUtf16Char(value);
        }

        public char Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Char();
        }
    }
    public sealed class NullableCharUtf16Formatter : IJsonFormatter<char?, char>
    {
        public static readonly NullableCharUtf16Formatter Default = new();
        private static readonly CharUtf16Formatter ElementFormatter = CharUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, char? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public char? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableCharUtf16ArrayFormatter : IJsonFormatter<char?[], char>
    {
        public static readonly NullableCharUtf16ArrayFormatter Default = new();
        private static readonly NullableCharUtf16Formatter ElementFormatter = NullableCharUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, char?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public char?[] Deserialize(ref JsonReader<char> reader)
        {
            char?[] temp = null;
            char?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<char?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<char?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableCharUtf16ListFormatter : IJsonFormatter<List<char?>, char>
    {
        public static readonly NullableCharUtf16ListFormatter Default = new();
        private static readonly NullableCharUtf16Formatter ElementFormatter = NullableCharUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<char?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<char?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<char?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class CharUtf16ArrayFormatter : IJsonFormatter<char[], char>
    {
        public static readonly CharUtf16ArrayFormatter Default = new();
        private static readonly CharUtf16Formatter ElementFormatter = CharUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, char[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public char[] Deserialize(ref JsonReader<char> reader)
        {
            char[] temp = null;
            char[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<char>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<char>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class CharUtf16ListFormatter : IJsonFormatter<List<char>, char>
    {
        public static readonly CharUtf16ListFormatter Default = new();
        private static readonly CharUtf16Formatter ElementFormatter = CharUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<char> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<char> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<char>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class CharUtf8Formatter : IJsonFormatter<char, byte>
    {
        public static readonly CharUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, char value)
        {
            writer.WriteUtf8Char(value);
        }

        public char Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Char();
        }
    }
    public sealed class NullableCharUtf8Formatter : IJsonFormatter<char?, byte>
    {
        public static readonly NullableCharUtf8Formatter Default = new();
        private static readonly CharUtf8Formatter ElementFormatter = CharUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, char? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public char? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableCharUtf8ArrayFormatter : IJsonFormatter<char?[], byte>
    {
        public static readonly NullableCharUtf8ArrayFormatter Default = new();
        private static readonly NullableCharUtf8Formatter ElementFormatter = NullableCharUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, char?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public char?[] Deserialize(ref JsonReader<byte> reader)
        {
            char?[] temp = null;
            char?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<char?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<char?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableCharUtf8ListFormatter : IJsonFormatter<List<char?>, byte>
    {
        public static readonly NullableCharUtf8ListFormatter Default = new();
        private static readonly NullableCharUtf8Formatter ElementFormatter = NullableCharUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<char?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<char?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<char?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class CharUtf8ArrayFormatter : IJsonFormatter<char[], byte>
    {
        public static readonly CharUtf8ArrayFormatter Default = new();
        private static readonly CharUtf8Formatter ElementFormatter = CharUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, char[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public char[] Deserialize(ref JsonReader<byte> reader)
        {
            char[] temp = null;
            char[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<char>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<char>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class CharUtf8ListFormatter : IJsonFormatter<List<char>, byte>
    {
        public static readonly CharUtf8ListFormatter Default = new();
        private static readonly CharUtf8Formatter ElementFormatter = CharUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<char> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<char> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<char>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateTimeUtf16Formatter : IJsonFormatter<DateTime, char>
    {
        public static readonly DateTimeUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, DateTime value)
        {
            writer.WriteUtf16DateTime(value);
        }

        public DateTime Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16DateTime();
        }
    }
    public sealed class NullableDateTimeUtf16Formatter : IJsonFormatter<DateTime?, char>
    {
        public static readonly NullableDateTimeUtf16Formatter Default = new();
        private static readonly DateTimeUtf16Formatter ElementFormatter = DateTimeUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateTime? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateTime? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateTimeUtf16ArrayFormatter : IJsonFormatter<DateTime?[], char>
    {
        public static readonly NullableDateTimeUtf16ArrayFormatter Default = new();
        private static readonly NullableDateTimeUtf16Formatter ElementFormatter = NullableDateTimeUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateTime?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateTime?[] Deserialize(ref JsonReader<char> reader)
        {
            DateTime?[] temp = null;
            DateTime?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTime?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateTimeUtf16ListFormatter : IJsonFormatter<List<DateTime?>, char>
    {
        public static readonly NullableDateTimeUtf16ListFormatter Default = new();
        private static readonly NullableDateTimeUtf16Formatter ElementFormatter = NullableDateTimeUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<DateTime?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateTime?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTime?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateTimeUtf16ArrayFormatter : IJsonFormatter<DateTime[], char>
    {
        public static readonly DateTimeUtf16ArrayFormatter Default = new();
        private static readonly DateTimeUtf16Formatter ElementFormatter = DateTimeUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateTime[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateTime[] Deserialize(ref JsonReader<char> reader)
        {
            DateTime[] temp = null;
            DateTime[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTime>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateTimeUtf16ListFormatter : IJsonFormatter<List<DateTime>, char>
    {
        public static readonly DateTimeUtf16ListFormatter Default = new();
        private static readonly DateTimeUtf16Formatter ElementFormatter = DateTimeUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<DateTime> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateTime> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTime>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateTimeUtf8Formatter : IJsonFormatter<DateTime, byte>
    {
        public static readonly DateTimeUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, DateTime value)
        {
            writer.WriteUtf8DateTime(value);
        }

        public DateTime Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8DateTime();
        }
    }
    public sealed class NullableDateTimeUtf8Formatter : IJsonFormatter<DateTime?, byte>
    {
        public static readonly NullableDateTimeUtf8Formatter Default = new();
        private static readonly DateTimeUtf8Formatter ElementFormatter = DateTimeUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateTime? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateTime? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateTimeUtf8ArrayFormatter : IJsonFormatter<DateTime?[], byte>
    {
        public static readonly NullableDateTimeUtf8ArrayFormatter Default = new();
        private static readonly NullableDateTimeUtf8Formatter ElementFormatter = NullableDateTimeUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateTime?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateTime?[] Deserialize(ref JsonReader<byte> reader)
        {
            DateTime?[] temp = null;
            DateTime?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTime?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateTimeUtf8ListFormatter : IJsonFormatter<List<DateTime?>, byte>
    {
        public static readonly NullableDateTimeUtf8ListFormatter Default = new();
        private static readonly NullableDateTimeUtf8Formatter ElementFormatter = NullableDateTimeUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<DateTime?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateTime?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTime?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateTimeUtf8ArrayFormatter : IJsonFormatter<DateTime[], byte>
    {
        public static readonly DateTimeUtf8ArrayFormatter Default = new();
        private static readonly DateTimeUtf8Formatter ElementFormatter = DateTimeUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateTime[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateTime[] Deserialize(ref JsonReader<byte> reader)
        {
            DateTime[] temp = null;
            DateTime[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTime>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateTimeUtf8ListFormatter : IJsonFormatter<List<DateTime>, byte>
    {
        public static readonly DateTimeUtf8ListFormatter Default = new();
        private static readonly DateTimeUtf8Formatter ElementFormatter = DateTimeUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<DateTime> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateTime> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTime>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateTimeOffsetUtf16Formatter : IJsonFormatter<DateTimeOffset, char>
    {
        public static readonly DateTimeOffsetUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, DateTimeOffset value)
        {
            writer.WriteUtf16DateTimeOffset(value);
        }

        public DateTimeOffset Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16DateTimeOffset();
        }
    }
    public sealed class NullableDateTimeOffsetUtf16Formatter : IJsonFormatter<DateTimeOffset?, char>
    {
        public static readonly NullableDateTimeOffsetUtf16Formatter Default = new();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = DateTimeOffsetUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateTimeOffset? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateTimeOffset? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateTimeOffsetUtf16ArrayFormatter : IJsonFormatter<DateTimeOffset?[], char>
    {
        public static readonly NullableDateTimeOffsetUtf16ArrayFormatter Default = new();
        private static readonly NullableDateTimeOffsetUtf16Formatter ElementFormatter = NullableDateTimeOffsetUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateTimeOffset?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateTimeOffset?[] Deserialize(ref JsonReader<char> reader)
        {
            DateTimeOffset?[] temp = null;
            DateTimeOffset?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTimeOffset?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateTimeOffsetUtf16ListFormatter : IJsonFormatter<List<DateTimeOffset?>, char>
    {
        public static readonly NullableDateTimeOffsetUtf16ListFormatter Default = new();
        private static readonly NullableDateTimeOffsetUtf16Formatter ElementFormatter = NullableDateTimeOffsetUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<DateTimeOffset?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateTimeOffset?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTimeOffset?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateTimeOffsetUtf16ArrayFormatter : IJsonFormatter<DateTimeOffset[], char>
    {
        public static readonly DateTimeOffsetUtf16ArrayFormatter Default = new();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = DateTimeOffsetUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateTimeOffset[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateTimeOffset[] Deserialize(ref JsonReader<char> reader)
        {
            DateTimeOffset[] temp = null;
            DateTimeOffset[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTimeOffset>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateTimeOffsetUtf16ListFormatter : IJsonFormatter<List<DateTimeOffset>, char>
    {
        public static readonly DateTimeOffsetUtf16ListFormatter Default = new();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = DateTimeOffsetUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<DateTimeOffset> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateTimeOffset> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTimeOffset>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateTimeOffsetUtf8Formatter : IJsonFormatter<DateTimeOffset, byte>
    {
        public static readonly DateTimeOffsetUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, DateTimeOffset value)
        {
            writer.WriteUtf8DateTimeOffset(value);
        }

        public DateTimeOffset Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8DateTimeOffset();
        }
    }
    public sealed class NullableDateTimeOffsetUtf8Formatter : IJsonFormatter<DateTimeOffset?, byte>
    {
        public static readonly NullableDateTimeOffsetUtf8Formatter Default = new();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = DateTimeOffsetUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateTimeOffset? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateTimeOffset? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateTimeOffsetUtf8ArrayFormatter : IJsonFormatter<DateTimeOffset?[], byte>
    {
        public static readonly NullableDateTimeOffsetUtf8ArrayFormatter Default = new();
        private static readonly NullableDateTimeOffsetUtf8Formatter ElementFormatter = NullableDateTimeOffsetUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateTimeOffset?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateTimeOffset?[] Deserialize(ref JsonReader<byte> reader)
        {
            DateTimeOffset?[] temp = null;
            DateTimeOffset?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTimeOffset?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateTimeOffsetUtf8ListFormatter : IJsonFormatter<List<DateTimeOffset?>, byte>
    {
        public static readonly NullableDateTimeOffsetUtf8ListFormatter Default = new();
        private static readonly NullableDateTimeOffsetUtf8Formatter ElementFormatter = NullableDateTimeOffsetUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<DateTimeOffset?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateTimeOffset?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTimeOffset?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateTimeOffsetUtf8ArrayFormatter : IJsonFormatter<DateTimeOffset[], byte>
    {
        public static readonly DateTimeOffsetUtf8ArrayFormatter Default = new();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = DateTimeOffsetUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateTimeOffset[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateTimeOffset[] Deserialize(ref JsonReader<byte> reader)
        {
            DateTimeOffset[] temp = null;
            DateTimeOffset[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTimeOffset>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateTimeOffsetUtf8ListFormatter : IJsonFormatter<List<DateTimeOffset>, byte>
    {
        public static readonly DateTimeOffsetUtf8ListFormatter Default = new();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = DateTimeOffsetUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<DateTimeOffset> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateTimeOffset> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTimeOffset>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class TimeSpanUtf16Formatter : IJsonFormatter<TimeSpan, char>
    {
        public static readonly TimeSpanUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, TimeSpan value)
        {
            writer.WriteUtf16TimeSpan(value);
        }

        public TimeSpan Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16TimeSpan();
        }
    }
    public sealed class NullableTimeSpanUtf16Formatter : IJsonFormatter<TimeSpan?, char>
    {
        public static readonly NullableTimeSpanUtf16Formatter Default = new();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = TimeSpanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, TimeSpan? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public TimeSpan? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableTimeSpanUtf16ArrayFormatter : IJsonFormatter<TimeSpan?[], char>
    {
        public static readonly NullableTimeSpanUtf16ArrayFormatter Default = new();
        private static readonly NullableTimeSpanUtf16Formatter ElementFormatter = NullableTimeSpanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, TimeSpan?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public TimeSpan?[] Deserialize(ref JsonReader<char> reader)
        {
            TimeSpan?[] temp = null;
            TimeSpan?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeSpan?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableTimeSpanUtf16ListFormatter : IJsonFormatter<List<TimeSpan?>, char>
    {
        public static readonly NullableTimeSpanUtf16ListFormatter Default = new();
        private static readonly NullableTimeSpanUtf16Formatter ElementFormatter = NullableTimeSpanUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<TimeSpan?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<TimeSpan?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeSpan?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class TimeSpanUtf16ArrayFormatter : IJsonFormatter<TimeSpan[], char>
    {
        public static readonly TimeSpanUtf16ArrayFormatter Default = new();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = TimeSpanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, TimeSpan[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public TimeSpan[] Deserialize(ref JsonReader<char> reader)
        {
            TimeSpan[] temp = null;
            TimeSpan[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeSpan>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class TimeSpanUtf16ListFormatter : IJsonFormatter<List<TimeSpan>, char>
    {
        public static readonly TimeSpanUtf16ListFormatter Default = new();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = TimeSpanUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<TimeSpan> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<TimeSpan> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeSpan>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class TimeSpanUtf8Formatter : IJsonFormatter<TimeSpan, byte>
    {
        public static readonly TimeSpanUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, TimeSpan value)
        {
            writer.WriteUtf8TimeSpan(value);
        }

        public TimeSpan Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8TimeSpan();
        }
    }
    public sealed class NullableTimeSpanUtf8Formatter : IJsonFormatter<TimeSpan?, byte>
    {
        public static readonly NullableTimeSpanUtf8Formatter Default = new();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = TimeSpanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, TimeSpan? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public TimeSpan? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableTimeSpanUtf8ArrayFormatter : IJsonFormatter<TimeSpan?[], byte>
    {
        public static readonly NullableTimeSpanUtf8ArrayFormatter Default = new();
        private static readonly NullableTimeSpanUtf8Formatter ElementFormatter = NullableTimeSpanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, TimeSpan?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public TimeSpan?[] Deserialize(ref JsonReader<byte> reader)
        {
            TimeSpan?[] temp = null;
            TimeSpan?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeSpan?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableTimeSpanUtf8ListFormatter : IJsonFormatter<List<TimeSpan?>, byte>
    {
        public static readonly NullableTimeSpanUtf8ListFormatter Default = new();
        private static readonly NullableTimeSpanUtf8Formatter ElementFormatter = NullableTimeSpanUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<TimeSpan?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<TimeSpan?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeSpan?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class TimeSpanUtf8ArrayFormatter : IJsonFormatter<TimeSpan[], byte>
    {
        public static readonly TimeSpanUtf8ArrayFormatter Default = new();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = TimeSpanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, TimeSpan[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public TimeSpan[] Deserialize(ref JsonReader<byte> reader)
        {
            TimeSpan[] temp = null;
            TimeSpan[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeSpan>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class TimeSpanUtf8ListFormatter : IJsonFormatter<List<TimeSpan>, byte>
    {
        public static readonly TimeSpanUtf8ListFormatter Default = new();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = TimeSpanUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<TimeSpan> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<TimeSpan> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeSpan>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateOnlyUtf16Formatter : IJsonFormatter<DateOnly, char>
    {
        public static readonly DateOnlyUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, DateOnly value)
        {
            writer.WriteUtf16DateOnly(value);
        }

        public DateOnly Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16DateOnly();
        }
    }
    public sealed class NullableDateOnlyUtf16Formatter : IJsonFormatter<DateOnly?, char>
    {
        public static readonly NullableDateOnlyUtf16Formatter Default = new();
        private static readonly DateOnlyUtf16Formatter ElementFormatter = DateOnlyUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateOnly? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateOnly? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateOnlyUtf16ArrayFormatter : IJsonFormatter<DateOnly?[], char>
    {
        public static readonly NullableDateOnlyUtf16ArrayFormatter Default = new();
        private static readonly NullableDateOnlyUtf16Formatter ElementFormatter = NullableDateOnlyUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateOnly?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateOnly?[] Deserialize(ref JsonReader<char> reader)
        {
            DateOnly?[] temp = null;
            DateOnly?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateOnly?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateOnly?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateOnlyUtf16ListFormatter : IJsonFormatter<List<DateOnly?>, char>
    {
        public static readonly NullableDateOnlyUtf16ListFormatter Default = new();
        private static readonly NullableDateOnlyUtf16Formatter ElementFormatter = NullableDateOnlyUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<DateOnly?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateOnly?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateOnly?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateOnlyUtf16ArrayFormatter : IJsonFormatter<DateOnly[], char>
    {
        public static readonly DateOnlyUtf16ArrayFormatter Default = new();
        private static readonly DateOnlyUtf16Formatter ElementFormatter = DateOnlyUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, DateOnly[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateOnly[] Deserialize(ref JsonReader<char> reader)
        {
            DateOnly[] temp = null;
            DateOnly[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateOnly>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateOnly>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateOnlyUtf16ListFormatter : IJsonFormatter<List<DateOnly>, char>
    {
        public static readonly DateOnlyUtf16ListFormatter Default = new();
        private static readonly DateOnlyUtf16Formatter ElementFormatter = DateOnlyUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<DateOnly> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateOnly> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateOnly>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateOnlyUtf8Formatter : IJsonFormatter<DateOnly, byte>
    {
        public static readonly DateOnlyUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, DateOnly value)
        {
            writer.WriteUtf8DateOnly(value);
        }

        public DateOnly Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8DateOnly();
        }
    }
    public sealed class NullableDateOnlyUtf8Formatter : IJsonFormatter<DateOnly?, byte>
    {
        public static readonly NullableDateOnlyUtf8Formatter Default = new();
        private static readonly DateOnlyUtf8Formatter ElementFormatter = DateOnlyUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateOnly? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateOnly? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateOnlyUtf8ArrayFormatter : IJsonFormatter<DateOnly?[], byte>
    {
        public static readonly NullableDateOnlyUtf8ArrayFormatter Default = new();
        private static readonly NullableDateOnlyUtf8Formatter ElementFormatter = NullableDateOnlyUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateOnly?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateOnly?[] Deserialize(ref JsonReader<byte> reader)
        {
            DateOnly?[] temp = null;
            DateOnly?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateOnly?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateOnly?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateOnlyUtf8ListFormatter : IJsonFormatter<List<DateOnly?>, byte>
    {
        public static readonly NullableDateOnlyUtf8ListFormatter Default = new();
        private static readonly NullableDateOnlyUtf8Formatter ElementFormatter = NullableDateOnlyUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<DateOnly?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateOnly?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateOnly?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateOnlyUtf8ArrayFormatter : IJsonFormatter<DateOnly[], byte>
    {
        public static readonly DateOnlyUtf8ArrayFormatter Default = new();
        private static readonly DateOnlyUtf8Formatter ElementFormatter = DateOnlyUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, DateOnly[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateOnly[] Deserialize(ref JsonReader<byte> reader)
        {
            DateOnly[] temp = null;
            DateOnly[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateOnly>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateOnly>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateOnlyUtf8ListFormatter : IJsonFormatter<List<DateOnly>, byte>
    {
        public static readonly DateOnlyUtf8ListFormatter Default = new();
        private static readonly DateOnlyUtf8Formatter ElementFormatter = DateOnlyUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<DateOnly> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateOnly> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateOnly>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class TimeOnlyUtf16Formatter : IJsonFormatter<TimeOnly, char>
    {
        public static readonly TimeOnlyUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, TimeOnly value)
        {
            writer.WriteUtf16TimeOnly(value);
        }

        public TimeOnly Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16TimeOnly();
        }
    }
    public sealed class NullableTimeOnlyUtf16Formatter : IJsonFormatter<TimeOnly?, char>
    {
        public static readonly NullableTimeOnlyUtf16Formatter Default = new();
        private static readonly TimeOnlyUtf16Formatter ElementFormatter = TimeOnlyUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, TimeOnly? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public TimeOnly? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableTimeOnlyUtf16ArrayFormatter : IJsonFormatter<TimeOnly?[], char>
    {
        public static readonly NullableTimeOnlyUtf16ArrayFormatter Default = new();
        private static readonly NullableTimeOnlyUtf16Formatter ElementFormatter = NullableTimeOnlyUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, TimeOnly?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public TimeOnly?[] Deserialize(ref JsonReader<char> reader)
        {
            TimeOnly?[] temp = null;
            TimeOnly?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeOnly?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeOnly?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableTimeOnlyUtf16ListFormatter : IJsonFormatter<List<TimeOnly?>, char>
    {
        public static readonly NullableTimeOnlyUtf16ListFormatter Default = new();
        private static readonly NullableTimeOnlyUtf16Formatter ElementFormatter = NullableTimeOnlyUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<TimeOnly?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<TimeOnly?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeOnly?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class TimeOnlyUtf16ArrayFormatter : IJsonFormatter<TimeOnly[], char>
    {
        public static readonly TimeOnlyUtf16ArrayFormatter Default = new();
        private static readonly TimeOnlyUtf16Formatter ElementFormatter = TimeOnlyUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, TimeOnly[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public TimeOnly[] Deserialize(ref JsonReader<char> reader)
        {
            TimeOnly[] temp = null;
            TimeOnly[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeOnly>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeOnly>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class TimeOnlyUtf16ListFormatter : IJsonFormatter<List<TimeOnly>, char>
    {
        public static readonly TimeOnlyUtf16ListFormatter Default = new();
        private static readonly TimeOnlyUtf16Formatter ElementFormatter = TimeOnlyUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<TimeOnly> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<TimeOnly> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeOnly>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class TimeOnlyUtf8Formatter : IJsonFormatter<TimeOnly, byte>
    {
        public static readonly TimeOnlyUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, TimeOnly value)
        {
            writer.WriteUtf8TimeOnly(value);
        }

        public TimeOnly Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8TimeOnly();
        }
    }
    public sealed class NullableTimeOnlyUtf8Formatter : IJsonFormatter<TimeOnly?, byte>
    {
        public static readonly NullableTimeOnlyUtf8Formatter Default = new();
        private static readonly TimeOnlyUtf8Formatter ElementFormatter = TimeOnlyUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, TimeOnly? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public TimeOnly? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableTimeOnlyUtf8ArrayFormatter : IJsonFormatter<TimeOnly?[], byte>
    {
        public static readonly NullableTimeOnlyUtf8ArrayFormatter Default = new();
        private static readonly NullableTimeOnlyUtf8Formatter ElementFormatter = NullableTimeOnlyUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, TimeOnly?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public TimeOnly?[] Deserialize(ref JsonReader<byte> reader)
        {
            TimeOnly?[] temp = null;
            TimeOnly?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeOnly?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeOnly?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableTimeOnlyUtf8ListFormatter : IJsonFormatter<List<TimeOnly?>, byte>
    {
        public static readonly NullableTimeOnlyUtf8ListFormatter Default = new();
        private static readonly NullableTimeOnlyUtf8Formatter ElementFormatter = NullableTimeOnlyUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<TimeOnly?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<TimeOnly?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeOnly?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class TimeOnlyUtf8ArrayFormatter : IJsonFormatter<TimeOnly[], byte>
    {
        public static readonly TimeOnlyUtf8ArrayFormatter Default = new();
        private static readonly TimeOnlyUtf8Formatter ElementFormatter = TimeOnlyUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, TimeOnly[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public TimeOnly[] Deserialize(ref JsonReader<byte> reader)
        {
            TimeOnly[] temp = null;
            TimeOnly[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeOnly>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeOnly>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class TimeOnlyUtf8ListFormatter : IJsonFormatter<List<TimeOnly>, byte>
    {
        public static readonly TimeOnlyUtf8ListFormatter Default = new();
        private static readonly TimeOnlyUtf8Formatter ElementFormatter = TimeOnlyUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<TimeOnly> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<TimeOnly> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeOnly>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class GuidUtf16Formatter : IJsonFormatter<Guid, char>
    {
        public static readonly GuidUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, Guid value)
        {
            writer.WriteUtf16Guid(value);
        }

        public Guid Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Guid();
        }
    }
    public sealed class NullableGuidUtf16Formatter : IJsonFormatter<Guid?, char>
    {
        public static readonly NullableGuidUtf16Formatter Default = new();
        private static readonly GuidUtf16Formatter ElementFormatter = GuidUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, Guid? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Guid? Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableGuidUtf16ArrayFormatter : IJsonFormatter<Guid?[], char>
    {
        public static readonly NullableGuidUtf16ArrayFormatter Default = new();
        private static readonly NullableGuidUtf16Formatter ElementFormatter = NullableGuidUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, Guid?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Guid?[] Deserialize(ref JsonReader<char> reader)
        {
            Guid?[] temp = null;
            Guid?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Guid?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableGuidUtf16ListFormatter : IJsonFormatter<List<Guid?>, char>
    {
        public static readonly NullableGuidUtf16ListFormatter Default = new();
        private static readonly NullableGuidUtf16Formatter ElementFormatter = NullableGuidUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<Guid?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Guid?> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Guid?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class GuidUtf16ArrayFormatter : IJsonFormatter<Guid[], char>
    {
        public static readonly GuidUtf16ArrayFormatter Default = new();
        private static readonly GuidUtf16Formatter ElementFormatter = GuidUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, Guid[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Guid[] Deserialize(ref JsonReader<char> reader)
        {
            Guid[] temp = null;
            Guid[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Guid>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class GuidUtf16ListFormatter : IJsonFormatter<List<Guid>, char>
    {
        public static readonly GuidUtf16ListFormatter Default = new();
        private static readonly GuidUtf16Formatter ElementFormatter = GuidUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<Guid> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Guid> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Guid>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class GuidUtf8Formatter : IJsonFormatter<Guid, byte>
    {
        public static readonly GuidUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, Guid value)
        {
            writer.WriteUtf8Guid(value);
        }

        public Guid Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Guid();
        }
    }
    public sealed class NullableGuidUtf8Formatter : IJsonFormatter<Guid?, byte>
    {
        public static readonly NullableGuidUtf8Formatter Default = new();
        private static readonly GuidUtf8Formatter ElementFormatter = GuidUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, Guid? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Guid? Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableGuidUtf8ArrayFormatter : IJsonFormatter<Guid?[], byte>
    {
        public static readonly NullableGuidUtf8ArrayFormatter Default = new();
        private static readonly NullableGuidUtf8Formatter ElementFormatter = NullableGuidUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, Guid?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Guid?[] Deserialize(ref JsonReader<byte> reader)
        {
            Guid?[] temp = null;
            Guid?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Guid?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableGuidUtf8ListFormatter : IJsonFormatter<List<Guid?>, byte>
    {
        public static readonly NullableGuidUtf8ListFormatter Default = new();
        private static readonly NullableGuidUtf8Formatter ElementFormatter = NullableGuidUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<Guid?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Guid?> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Guid?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class GuidUtf8ArrayFormatter : IJsonFormatter<Guid[], byte>
    {
        public static readonly GuidUtf8ArrayFormatter Default = new();
        private static readonly GuidUtf8Formatter ElementFormatter = GuidUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, Guid[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Guid[] Deserialize(ref JsonReader<byte> reader)
        {
            Guid[] temp = null;
            Guid[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Guid>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class GuidUtf8ListFormatter : IJsonFormatter<List<Guid>, byte>
    {
        public static readonly GuidUtf8ListFormatter Default = new();
        private static readonly GuidUtf8Formatter ElementFormatter = GuidUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<Guid> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Guid> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Guid>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class StringUtf16Formatter : IJsonFormatter<string, char>
    {
        public static readonly StringUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, string value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16String(value);
        }

        public string Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16String();
        }
    }

    public sealed class StringUtf16ArrayFormatter : IJsonFormatter<string[], char>
    {
        public static readonly StringUtf16ArrayFormatter Default = new();
        private static readonly StringUtf16Formatter ElementFormatter = StringUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, string[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public string[] Deserialize(ref JsonReader<char> reader)
        {
            string[] temp = null;
            string[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<string>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<string>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class StringUtf16ListFormatter : IJsonFormatter<List<string>, char>
    {
        public static readonly StringUtf16ListFormatter Default = new();
        private static readonly StringUtf16Formatter ElementFormatter = StringUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<string> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<string> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<string>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class StringUtf8Formatter : IJsonFormatter<string, byte>
    {
        public static readonly StringUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, string value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8String(value);
        }

        public string Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8String();
        }
    }

    public sealed class StringUtf8ArrayFormatter : IJsonFormatter<string[], byte>
    {
        public static readonly StringUtf8ArrayFormatter Default = new();
        private static readonly StringUtf8Formatter ElementFormatter = StringUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, string[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public string[] Deserialize(ref JsonReader<byte> reader)
        {
            string[] temp = null;
            string[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<string>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<string>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class StringUtf8ListFormatter : IJsonFormatter<List<string>, byte>
    {
        public static readonly StringUtf8ListFormatter Default = new();
        private static readonly StringUtf8Formatter ElementFormatter = StringUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<string> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<string> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<string>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class VersionUtf16Formatter : IJsonFormatter<Version, char>
    {
        public static readonly VersionUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, Version value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16Version(value);
        }

        public Version Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Version();
        }
    }

    public sealed class VersionUtf16ArrayFormatter : IJsonFormatter<Version[], char>
    {
        public static readonly VersionUtf16ArrayFormatter Default = new();
        private static readonly VersionUtf16Formatter ElementFormatter = VersionUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, Version[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Version[] Deserialize(ref JsonReader<char> reader)
        {
            Version[] temp = null;
            Version[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Version>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class VersionUtf16ListFormatter : IJsonFormatter<List<Version>, char>
    {
        public static readonly VersionUtf16ListFormatter Default = new();
        private static readonly VersionUtf16Formatter ElementFormatter = VersionUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<Version> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Version> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Version>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class VersionUtf8Formatter : IJsonFormatter<Version, byte>
    {
        public static readonly VersionUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, Version value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8Version(value);
        }

        public Version Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Version();
        }
    }

    public sealed class VersionUtf8ArrayFormatter : IJsonFormatter<Version[], byte>
    {
        public static readonly VersionUtf8ArrayFormatter Default = new();
        private static readonly VersionUtf8Formatter ElementFormatter = VersionUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, Version[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Version[] Deserialize(ref JsonReader<byte> reader)
        {
            Version[] temp = null;
            Version[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Version>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class VersionUtf8ListFormatter : IJsonFormatter<List<Version>, byte>
    {
        public static readonly VersionUtf8ListFormatter Default = new();
        private static readonly VersionUtf8Formatter ElementFormatter = VersionUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<Version> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Version> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Version>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UriUtf16Formatter : IJsonFormatter<Uri, char>
    {
        public static readonly UriUtf16Formatter Default = new();

        public void Serialize(ref JsonWriter<char> writer, Uri value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16Uri(value);
        }

        public Uri Deserialize(ref JsonReader<char> reader)
        {
            return reader.ReadUtf16Uri();
        }
    }

    public sealed class UriUtf16ArrayFormatter : IJsonFormatter<Uri[], char>
    {
        public static readonly UriUtf16ArrayFormatter Default = new();
        private static readonly UriUtf16Formatter ElementFormatter = UriUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<char> writer, Uri[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Uri[] Deserialize(ref JsonReader<char> reader)
        {
            Uri[] temp = null;
            Uri[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Uri>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UriUtf16ListFormatter : IJsonFormatter<List<Uri>, char>
    {
        public static readonly UriUtf16ListFormatter Default = new();
        private static readonly UriUtf16Formatter ElementFormatter = UriUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<char> writer, List<Uri> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Uri> Deserialize(ref JsonReader<char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Uri>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UriUtf8Formatter : IJsonFormatter<Uri, byte>
    {
        public static readonly UriUtf8Formatter Default = new();

        public void Serialize(ref JsonWriter<byte> writer, Uri value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8Uri(value);
        }

        public Uri Deserialize(ref JsonReader<byte> reader)
        {
            return reader.ReadUtf8Uri();
        }
    }

    public sealed class UriUtf8ArrayFormatter : IJsonFormatter<Uri[], byte>
    {
        public static readonly UriUtf8ArrayFormatter Default = new();
        private static readonly UriUtf8Formatter ElementFormatter = UriUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<byte> writer, Uri[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Uri[] Deserialize(ref JsonReader<byte> reader)
        {
            Uri[] temp = null;
            Uri[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Uri>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = [];
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UriUtf8ListFormatter : IJsonFormatter<List<Uri>, byte>
    {
        public static readonly UriUtf8ListFormatter Default = new();
        private static readonly UriUtf8Formatter ElementFormatter = UriUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<byte> writer, List<Uri> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Uri> Deserialize(ref JsonReader<byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Uri>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
}